# 内存管理系统

## makefile简介

依赖关系是定义在文件 makefile 中，make 程序通过解析 makefile 文件，自动找出变更的文件以及依赖此变更文件的相关文件，然后对所有受影响的相关文件执行事先定义好的命令规则。

### 基本语法

> 目标文件:依赖文件
> [Tab]命令

在 Linux 中，文件分为属性和数据两部分，每个文件有三种时间，分别用于记录与文件属性和文件数
据相关的时间，这三个时间分别是 atime、mtime、ctime。
（1）atime，即 access time，表示访问文件数据部分时间，每次读取文件数据部分时就会更新 atime，强调下，
是读取文件数据（内容）时改变 atime，比如 cat 或 less 命令查看文件就可以更新 atime，而 ls 命令则不会。
（2）ctime，即 change time，表示文件属性或数据的改变时间，每当文件的属性或数据被修改时，就
会更新 ctime，也就是说 ctime 同时跟踪文件属性和文件数据变化的时间。
（3）mtime，即 modify time，表示文件数据部分的修改时间，每次文件的数据被修改时就会更新 mtime。
在上面说过啦，ctime 也跟踪数据变化时间，所以，当文件数据被修改时，mtime 和 ctime 一同更新

>  1:2
>  echo "makefile test ok"

此 makefile 的意义是如果文件 2 的 mtime 比文件 1 的 mtime 要新，就调用 echo 命令打印字符串“makefile test ok”.

GNUmakefile >> makefile >> Makefile

![image-20250111121131303](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250111121131303.png)

### 自定义变量与系统变量

```makefile
#变量名=值
#多个值之间用空格分开
#变量的引用格式是$(变量名)
```

![image-20250111121648330](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250111121648330.png)

## 实现`assert`断言

## 位图bitmap及其函数的实现

### 位图简介

位图，也就是`bitmap`，广泛用于资源管理，是一种管理资源的方式、手段。

位图包含两个概念：**位**和**图**.

图是指map,map这个词本质上就是映射的意思，映射，即对应关系。综合起来就是用字节中的1位来映射其他单位大小的资源。

计算机中最小的**数据单位是位**，于是，用一组二进制位串来管理其他单位大小的资源是很自然的事，这组二进制位中的每一位与其他资源中的数据单位都是**一对一**的关系，这实际就成了一种映射，即 map，于是这组二进制位就有了更恰当的名字—位图。

因此位图的一字节对等表示8个资源单位。(被人工划分为两种状态)

![image-20250112180751706](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250112180751706.png)

其中， “管理结构的单位大小”是指位图中的 1 位，也就是图 8-17 位图框中的“黑点” “资源自己的单位大小”就是指以 4KB 为单位大小的内存，也就是图中每一个 4KB 的小格子。注意，内存本身最小可寻址单位是字节，4KB 是
人为划分的内存单位，内存中可没有一个个 4KB 大小的“格子” 。之所以这样做，原因就像上面所说的，将所管理资源的单位调整到最大。当然，为了高效管理，这个资源单位并不是越大越好，得方便管理才合适。

### 位图的定义与实现

## 内存管理系统

### 内存池规划

内存池：**池**，意为池塘、也就是水源仓库，他起到水源存储、集中管理的作用，需要水的时候直接从池中取出即可。内存地址池的概念是将**可用的内存地址**集中放到一个“池子”中，需要的时候直接从里面取出，用完后在放回去。为了有效**管理**他们，我们需要创建**虚拟内存地址池**和**物理内存地址池**。

内存池中管理的是一个个大小为 4KB 的内存块，从内存池中获取的内存大小至少为 4KB 或者为 4KB 的倍数。

![image-20250112185145361](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250112185145361.png)

**申请者**向内存管理系统，也就是操作系统，申请内存时，操作系统先从**申请者自己的怒你地址池**分配空闲虚拟地址，然后在从**申请者物理内存池**中分配空闲的物理内存，然后在**申请者自身的页表**将这两种地址建立好映射关系.

### 分配页内存

在loader中创建页表的时候，在最后一个页目录项里写的是页目录表自己物理地址，目的就是通过此页目录项编辑页表。



# 加载流程

## MBR

1. CPU从ROM中读取BIOS代码
2. BIOS加载MBR
3. MBR读取磁盘获取loader程序，跳转到loader

## loader

1. 获取内存
2. 打开A20地址线，加载GDT,将cr0PE位置1
3. 进入保护模式
4. 读取磁盘读取内核
5. 开启分页（设置页目录/页表，打开 `cr0` PG 位）。
6. 重新加载GDT,GDT的基地址发生了高地址映射，需要再次执行
7. 跳转到内核

## kernel

初始化各个子系统(中断，idt，内存，进程)







**bug**:在最开始的include中的boot中DESC_DPL打成了DESC_CPL.

ards_buf->adrsbuf.

创建页表的时候两个寄存器名称写错。
