# 用户进程

## 为什么要有任务状态段TSS

### LDT简介

程序从文件系统上被加载到内存后，位于内存中的程序便称为映像，也称为任务

按照内存分段的方式，内存中的程序映像自然被分成了代码段、数据段等资源，这些资源属于程序私有的部分，因此，为每个程序单独赋予一个结构来存储其私有的资源，这个结构就是LDT.

`LDT`是`Local Descriptor Table`，即局部描述符表。

![image-20250117153538583](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117153538583.png)

在LDT中，描述符的D位和L位固定为0.

LDT描述符属于系统段描述符，因此S为0.在S为0的前提下，若TYPE的值为0010,则表示此描述符是LDT描述符。

和GDT一样、CPU专门准备了个寄存器来存储其位置及偏移量。就是`LDTR`。

指令lldt是LDTR的配套指令，指令格式为:

```assembly
lldt ”16位通用寄存器“或”16位内存单元“		;操作数必须是LDT选择子
```

![image-20250117154616975](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117154616975.png)

选择器中是16位的LDT选择子，描述符缓冲器中是LDT的起始地址及偏移大小。

![image-20250117154941700](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117154941700.png)

### TSS的作用

任何时候，寄存器中的内容才是任务的最新状态，采取轮流使用**CPU**的方式运行多任务，当前任务被换下时，任务的最新状态，也就是寄存器中的内容应该找个地方保存起来。因此给每个任务"关联"一个任务状态段，这就是`TSS(Task State Segment)`，用它来表示任务。

程序员为任务单独定义的一个结构体变量，CPU自动用此结构体保存任务的状态和自动从此结构体变量中载入任务的状态。TSS就是任务的代表，CPU用不同的TSS区分不同的任务，因此任务切换的本质就是TSS的换来换去。



在CPU中有一个专门存储**TSS信息的寄存器**，这就是**TR寄存器**，始终指向当前正在运行的任务。

![image-20250117160038608](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117160038608.png)

TSS描述符属于系统段描述符符，因此S为0,在S为0的情况下，`TYPE`的值为10B1.B位表示busy为，为0表示任务不繁忙，为1表示任务繁忙。

**B位存在的意义是为了给当前任务打个标记，目的是避免当前任务调用自己，也就是任务是不可重入的。**

![image-20250117160801738](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117160801738.png)

TSS中的阻断基本上全是寄存器名称，这些**寄存器**就是任务运行中的**最新状态**。类似于拍照片，胶片上记录的是事务当时的最新状态，因此也称为**快照**。可见TSS的主要作用就是**保存任务的快照**。

除了一般的寄存器外，TSS 中还有“I/O 位图”和“上一个任务的 TSS 指针” ，分别位于 TSS 结构图的左上角和右下角。

**SS0和esp0,SS1和esp1,SS2和esp2,这三组栈仅仅是CPU用来由低特权级进入高特权级是用的**，因此CPU并不会主动在TSS中更新相应特权级的栈指针。

![image-20250117162327738](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117162327738.png)

将tss加载到寄存器**TR**的指令是**ltr**：

```assembly
ltr "16位通用寄存器" 或 "16位内存单元"
```

![image-20250117162555157](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117162555157.png)

### CPU原生支持的任务切换方式

原本计划的一种方式

1. 通过"中断+任务门"进行任务切换

​	优点：

* 实现简单
* 抢占式多任务调度，所有任务都有运行的机会

![image-20250117163437133](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117163437133.png)

任务门描述符也是系统段，因此S的值为0,在S为0的情况下，TYPE的值是010,就表示此描述符是任务门描述符。

**iretd**有两个功能

1. 从中断返回到当前任务的中断前代码处
2. 当前任务是被嵌套调用时，他会调用自己TSS中"上一个任务的TSS指针"的任务，也就是返回到上一个任务

**iretd可以调用一个任务**。

![image-20250117164021031](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117164021031.png)

![image-20250117164148721](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117164148721.png)

![image-20250117164613037](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117164613037.png)

2.call、jmp切换任务

* 任务门描述符除了可以在IDT中注册，还可以在GDT和LDT中注册
* 任务以TSS为代表，只要包括TSS选择子的对象都可以作为任务切换的操作数

![image-20250117165152584](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250117165152584.png)

### 现代操作系统采用的任务切换方式

常见的指令集有两大派系：复杂指令集CISC和精简指令集RISC.

x86使用的指令属于CISC,在此指令集的发展过程中，工程师为了让程序员少写代码，把**指令的功能做得越发强大**，因此在 **RISC 中多条**指令才能完成的工作，在 CISC 中只用一条指令就完成了。看上去感觉很爽的样子，但这只是**开发效率上的提升**，**执行效率却下降了**，原因是：表面强大的功能是用内部复杂、数量更多的微操作换来的，也
就是说，**CISC 的强大需要更多的时钟周期作为代价。**

> 最后，一个任务需要单独关联一个 TSS，TSS 需要在 GDT 中注册，GDT 中最多支持 8192 个描述符，
> 为了支持更多的任务，随着任务的增减，要及时修改 GDT，在其中增减 TSS 描述符，修改过后还要重新
> 加载 GDT。这种频繁修改描述符表的操作还是很消耗 CPU 资源的。

**我们使用TSS唯一的理由是为0特权级的任务提供栈**



`Linux`为每一个CPU创建一个TSS,在各个CPU上的所有任务共享同一个TSS,各CPU的TR寄存器保存各CPU上的TSS。用ltr指令加载后，该TR寄存器永远指向同一个TSS.在切换进程时，只需把TSS中的SS0及esp0更新为新任务的内核栈的段地址及栈指针。`Linux在TSS中只初始化了SS0、esp0和I/O位图字段`



是这样的，当 CPU 由**低特权级**进入**高特权**级时，CPU 会“自动”从 TSS 中获取对应**高特权级的栈指
针**（TSS 是 CPU 内部框架原生支持的嘛，当然是自动从中获取新的栈指针）。我们具体说一下，Linux 只
用到了**特权 3 级和特权 0 级**，因此 CPU 从 3 特权级的用户态进入 0 特权级的内核态时（比如从用户进程进入中断） ，CPU 自动从当前任务的 **TSS 中获取 SS0 和 esp0 字段的值作为 0 特权级的栈**，然后 Linux“手
动”执行一系列的 **push 指令将任务的状态的保存在 0 特权级栈中**，也就是 TSS 中 SS0 和 esp0 所指向的栈。

## 定义并初始化TSS

学习linux任务切换的方式，只修改TSS中的特权级0对应的栈。

函数`update_tss_esp`来更新tss中的esp0.

## 实现用户进程

### 实现用户进程的原理

![image-20250118131419036](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118131419036.png)

### 用户进程的虚拟地址空间

页表寄存器cr3中的应该是页目录表的物理地址，但pgdir是虚拟地址，这是什么原因？

​	由于页目录表本身也要占用**内存来存储**，在为进程创建页目录表时，必然要**申请内存**，但内存管理系统返回的地址肯定**都是虚拟地址**，及时返回物理地址，在分页机制下，引用的任何地址都被当作虚拟地址，该"物理地址"也要**再次被转换成别的物理地址**。

### 为进程创建页表和3特权级栈

### 进入特权级3

一般情况下，CPU不允许从高特权级转向低特权级，除非是中断门和调用门。

从中断返回肯定要用到`irted`指令，`irted`指令会用到栈中的数据作为返回地址，还会加载栈中`eflags`的值到`eflags`寄存器，如果栈中cs.rpl若为更低的特权级，处理器的特权级检查通过后，会将栈中cs载入到`CS`寄存器，栈中ss载入到`SS`寄存器。

在汇编函数**intr_exit**里的一系列pop操作是为了恢复任务的上下文，因此我们必须提前准备好用户进程所用的栈结构， **在里面装填好用户进程的上下文信息**，借一系列**pop出栈**的机会，将用户进程的上下文信息**载入CPU**的寄存器，为用户进程的**运行准备环境**

**RPL是选择子中的低2位，用以表示访问者特权级，因此RPL是为了避免低特权级任务作弊使用指向高特权级内存段的选择子而提供的一种检测手段**

关键点：

* 从中断返回，必须要经过`intr_exit`，即使是“假装”
* 提前准备好用户进程所用的栈结构
* 我门要在栈中存储的CS选择子，其RPL必须为3
* 栈中段寄存器的选择子必须指向DPL为3
* 必须使栈中eflags的IF位为1
* eflgas的IOPL位为0

### 用户进程创建的流程

![image-20250118145253453](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118145253453.png)

进程从创建到运行总体上分为两步：

* 由函数`process_execute`创建
* 由时钟中断调用`schedule`调度进程

### 实现用户进程--上

声明外部函数`intr_exit`,这是用户进程进入3特权级的关键。

用户程序在执行前，是由操作系统的**程序加载器**将用户程序**从文件系统读到内存**，在**根据程序文件的格式解析**其内容，将程序中的**段展开到相应的内存地址**。程序格式中会**记录程序入口的地址**，CPU把**CS:[E]IP**指向他，程序就被执行了。

C 语言中虽然不能直接控制这两个寄存器，但函数调用其实就是改变这两个寄存器的指向，故 C 语言编写的操作系统可以像调用函数那样调用执行用户程序。

![image-20250118170827991](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118170827991.png)

结构体中成员的地址是越往下越高，但栈中元素越往下越低。

![image-20250118185707262](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118185707262.png)

在`4GB`的虚拟地址空间中，(0xc0000000-1)是用户空间的最高地址，0xc0000000～0xffffffff是内核空间。

每个进程都拥有独立的虚拟地址空间，本质上就是各个进程都有单独的页表，页表是存储在CR3中的，CR3寄存器只有一个，因此，不同的进程在执行之前，我们要在CR3寄存器总为其换上配套的页表。

### bss简介

在c程序的内存空间中，位于低处的三个段是代码段、数据段和bss段，他们是由编译器和链接器规划地址空间，在程序被操作系统加载之前他们地址就固定了。

因此在程序的**加载之初**，操作系统必须为**堆和栈分别指定起始地址**。

为什么要将 section 合并成 segment？这么做的原因也很简单，

* 保护模式下的安全检查
* 操作系统在加载程序时省事

在操作系统的视角中，它只关心程序中这些节的属性是什么。以便加载程序时为其分配不同的段选择子，从而使程序内存指向不同的段描述符，起到保护内存的作用。因此最好是**链接器**把目标文件中**属性相同的节合并到一起**，这样操作系统便可统一为其分配内存。

1. 可读写的数据，如数据节.data和未初始化节.bss
2. 只读可执行的代码，如代码节.text和初始化代码节.init
3. 只读数据，如只读数据节.rodata,一般情况下字符串就存储在此节

bss中的数据是**未初始化的全局变量**和**局部静态变量**。

bss区域的目的就是提前为这些未初始化数据预留内存空间。

链接器的做法：由于bss中的内容是**变量**，其属性为可读写，这和数据段属性一致，故链接器经bss占用的内存空间大小合并到数据段占用的内存中，这样便在数据段中预留出bss的空间以供程序在将来运行时使用。

### 实现用户进程--下

![image-20250118195701428](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118195701428.png)



#### 软链接 

符号链接是Linux系统中的概念。文件都有名称，对于用户来说，文件是通过文件名来访问的，可以把文件名理解为存储在磁盘上的文件实体的访问入口。**符号链接是为同一个文件实体多创建了一个访问入口。**

![image-20250118200129168](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250118200129168.png)

页表是记录在页目录项中，此处页目录项对于内核物理内存的作用，相当于 Linux 中文件的符号链接，**页目录项**是访问**内核所在物理内存的入口**。

也就是把用户进程页目录表中的第 768～1023 个页目录项用内核页目录表的第 768～1023 个页目录项代替，其实就是将内核所在的页目录项复制到进程页目录表中同等位置，这样就能让用户进程的高 1GB 空间指向内核
