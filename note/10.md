# 输入输出系统

## 同步机制----锁

死锁的必要条件

* 互斥
* 请求与保持
* 不剥夺锁
* 循环等待

### 排查GP异常，理解原子操作

少字符的问题出现在不同种类的字符串"交界"的地方。

字符打印函数`put_char`的原理：

1. 获取光标值
2. 将光标值转换为字节地址，在该地址处写入字符
3. 更新光标的值

以上三个步骤必须一气呵成，不能被调度机制拆分，因此字符打印必须具有原子性。

因此问题出现在任务调度破坏了字符打印的原子性。

GP异常：

![image-20250114201258830](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114201258830.png)

光标寄存器为公共资源。

![image-20250114202147958](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114202147958.png)

根本原因是：**访问公共资源需要多个操作，而这多个操作的执行过程不具备原子性，被任务调度器断开了，从而让其他线程有机会破坏显存和光标寄存器这两类公共资源的现场。**

### 找出代码中的临界区、互斥、竞争条件

* 公共资源

​	被所有任务共享的一套资源

* 临界区

​	临界区是指程序中那些访问公共资源的指令代码，是指令，而不是静态公共资源

* 互斥

​	某一时刻公共资源只能被一个任务独享，即只能有一个任务在自己的临界区中执行

* 竞争条件

  竞争条件是指多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。

单条指令的执行具有原子性。

多线程访问公共资源时出问题的原因是产生了**竞争条件**，也就是**多个任务同时出现在自己的临界区**。为避免产生竞争条件，必须保证任意时刻只能有一个任务处于临界区。因此，只要保证**各线程自己临界区中的所有代码
都是原子操作**，即临界区中的指令要么一条不做，要么一气呵成全部执行完，执行期间绝对不能被换下处理器。
当然，临界区中**很少存在只有一条指令的情况**，因此我们必须**提供一种互斥的机制**，互斥能使临界区具有原子性，避免产生竞争条件，从而避免了多任务访问公共资源时出问题。

### 信号量

在计算机中，信号量就是个0以上的整数值，当为0时表示已无可用信号，或者说条件不再允许，因此它表示某种信号的积累“量”，故称为信号量。

**信号量是种同步机制**。同步简单来说就是不能随时随意工作，工作必须在某种条件具备的情况下才能开始，工作条件具备的时间顺序就是时序。

增加操作`up`包括两个微操作

1. 将信号量的值加1
2. 唤醒在此信号量上等待的线程

减少操作`down`包括三个微操作

1. 判断信号量是否大于0
2. 若信号量大于0,则将信号量减1
3. 若信号量等于0,当前线程将自己阻塞，以在此信号量上等待

信号量的处置代表是信号资源的积累量，也就是剩余量，若初值为1的话，它的取值就只能为0和1,这便称为二元信号量，我们可以用二元信号量来实现锁

在二元信号量中，**down**操作就是获得锁，**up**操作就是释放锁。我们可以让线程通过锁进入临界区，可以借此保证只有一个线程可以进入临界区。大致流程为：

* 线程 A 进入临界区前先通过 down 操作获得锁（我们有强制通过锁进入临界区的手段），此时信号
  量的值便为 0。
*  后续线程 B 再进入临界区时也通过 down 操作获得锁，由于信号量为 0，线程 B 便在此信号量上
  等待，也就是相当于线程 B 进入了睡眠态。
* 当线程 A 从临界区出来后执行 up 操作释放锁，此时信号量的值重新变成 1，之后线程 A 将线程 B
  唤醒。
* 线程 B 醒来后获得了锁，进入临界区。

### 线程的阻塞与唤醒

不让线程在就绪队列中出现，这样线程便没有机会运行，也就实现了线程的阻塞。

阻塞发生的时间是在线程自己的运行过程中，是线程自己阻塞自己，并不是被谁阻塞。

唤醒已阻塞的线程是由别的线程，通常是锁的持有者来做的。

### 锁的实现

## 用锁实现终端输出

虚拟中断就是我们熟知的`tty`，tty指`电传打字机`，即`TeleTYpes`.

虚拟终端的实现：

显卡提供了两个寄存器`Start Address High Register`和`Start Address Low Register`,来设置数组在显存中的起始地址。

起始地址是用 16 位来表示的，它们分别设置显存地址的 15～8 位和 7～0 位。因此，我们可以把不同的 16 位地址分别写入这两个寄存器，从而实现将显存分块显示的目的，也就是实现了虚拟终端。

![image-20250116105928311](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116105928311.png)

切换不同的控制台，每次切换后台对应的操作就是变换那两个寄存器中的起始地址。

从远程连接到Linux主机的终端称为**pts**。

## 从键盘获取输入

键盘是个独立的设备，在他内部有个叫做`键盘编码器的芯片`。作用是：每当键盘上发生案件操作，它就向键盘控制器报告那个按键被按下，是否弹起。

键盘控制器在主机内部的主板上。作用是：接收来自键盘编码器的按键信息，将其解码后保存，然后向中断代理发中断。

![image-20250116114345918](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116114345918.png)

8048与8042对键盘上的所有按键进行编码，也就是每个按键都有数值，所有按键对应的数值便组成了一张"按键-数值"表，叫做**键盘扫描码**。

一个键的状态要么是按下，要么是弹起，因此一个键便有两个编码，按键被按下时的编码也叫通码，通码也称**makecode**，按键被弹起叫断码，也就是**breakcode**。

### 键盘扫描码

根据不同的编码方案，键盘扫描码有三套，分别称为 scan code set 1、scan code set 2、scan code set 3.

为了兼容，当键盘将扫描码发送到8042后，都由8042转换成第一套扫描码。

大多数情况下第一套扫描码中的通码和断码都是 1 字节大小。您看，表 10-1 中的通码和断码，它们的关
系是：**断码 = 0x80 + 通码**。顺便说一句，在第二套键盘扫描码中，一般的**通码是 1 字节大小**，断码是在通码
前再加 **1 字节的 0xF0**，**共 2 字节**，我们的 8042 工作之一就是根据第二套扫描码中通码和断码的关系将它们解
码，然后按照第一套扫描码中通码和断码的关系转换成第一套扫描码。

![image-20250116120244026](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116120244026.png)

在每一次击键动作的“按下”、“按下保持”、“弹起”三个阶段。

*  扫描码有 3 套，现在一般键盘中的 8048 芯片支持的是第二套扫描码。因此每当有击键发生时， 8048
  发给 8042 的都是第二套键盘扫描码。
*  8042 为了兼容性，将接收到的第二套键盘扫描码转换成第一套扫描码。8042 是按字节来处理的，
  每处理一个字节的扫描码后，将其存储到自己的输出缓冲区寄存器
*  然后向中断代理 8059A 发中断信号，这样我们的键盘中断处理程序通过读取 8042 的输出缓冲区
  寄存器，会获得第一套键盘扫描码。

![image-20250116121548364](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116121548364.png)

### 8042简介

**Intel 8042 芯片或兼容芯片**被集成在主板上的**南桥芯片**中，它是键盘控制器，也就是键盘的 IO 接口，
因此它是 8048 的代理，也是前面所得到的处理器和键盘的“中间层” 。8048 通过**PS/2、USB** 等接口与 8042
通信，处理器通过**端口与 8042 通信**（IO 接口就是外部硬件的代理，它和处理器都位于主机内部，因此处
理器与 IO 接口可以通过端口直接通信）。

![image-20250116122143333](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116122143333.png)

8042是连接8048和处理器的桥梁、存在的目的是：为了处理器可以通过他控制8048的工作方式，然后让8048的工作成果通过8042回传给处理器。此时8042就相当于数据的缓冲区、中转站，8042的作用分别是输入和输出。

![image-20250116122538737](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116122538737.png)

![image-20250116122807389](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116122807389.png)

**根据ABI约定，返回值是存在`寄存器eax`中的**

## 编写键盘驱动

我们将复杂的硬件控制指令封装成一个过程，每次只把对硬件的操作需求提交给此过程，由此过程实施底层的控制细节，然后返回给调用者一个结果，这个直接同底层硬件打交道的过程便是驱动程序。

定义的二维数组**keymap**是键盘驱动的核心，此数组主要定义了与`shift`组合时的字符效果。

主键盘区主要是与上档键`shift`配合使用，如果之前已经按下了 shift 键并且按住不松手：

* 当在主键盘区中按下数字键时，这表示按键为数字上面的符号，如'3'变成了'#'。
* 当在主键盘区中按下字母键时，这表示按键为大写字母，如'a'变成了'A'。

程序步骤：

1. 获取上次输入中断的状态(ctrl、shift、capslock)
2. 读取扫描码
3. 是否是2字节编码，如果是，推出再次读入，并将标志位置1
4. 判断2字节标志位，如果为1,将本次读入数据与0xe0合并
5. 获取断码，如果断码为1,则是按键取消，判断是否为特殊字符，将对应的标志位状态进行更改
6. 然后直接退出
7. 如果是通码makecode,判断是否是可打印字符
8. 判断shift与capslock的作用
9. 打印
10. 判断是否为控制键，如果是设置状态位.

## 环形输入缓冲区

### 生产者与消费者问题简述

“同步”是指多个线程相互协作、共同完成一个任务，属于线程间工作步调的相互制约。"互斥"是指多个线程"分时"访问共享资源。

![image-20250116213908509](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116213908509.png)

生产者与消费者问题描述的是:

​	对于有限大小的公共缓冲区，如何同步生产者与消费者的运行，以达到对共享缓冲区的互斥访问，并且保证生产者不会过度生产、消费者不会过度消费、缓冲区不会被破坏。

### 环形缓冲区的实现

![image-20250116215943622](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250116215943622.png)
