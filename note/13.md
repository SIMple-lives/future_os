# 编写硬盘驱动程序

## 硬盘及分区表

### 创建从盘及获取安装的磁盘数

在bochs中用xp/b命令查看物理地址0x475处的一字节，表示硬盘数量。

创建大小为80MB的硬盘作为从盘，在其上安装文件系统。

```bash
Creating hard disk image 'file.img' with CHS=162/16/63 (sector size = 512)

```

### 创建磁盘分区表

文件系统是运行在操作系统中的**软件模块**，是**操作系统**提供的一套**管理磁盘文件**读写的方法和数据组织、存储形式。因此**文件系统=数据结构+算法**

`盘片`：类似光盘中的一个圆盘，上面布满了磁性介质。

`扇区`：扇区是**硬盘读写**的基本单位，扇区从**1开始编号**。扇区的大小字节数=256 * N，N为自然数。

通常N取2,因此扇区大小为512字节。

为了优化I/O,操作系统把数据积攒到"多个扇区"时再一次性写入磁盘，这里的"多个扇区"就是操作系统的簇或块。

`磁道`：盘片上的一个个**同心圈**就是磁道，是扇区的载体，每一个磁道由外向里从0开始编号。

`磁头`：一个盘片分为上下两个面，各面都有一个磁头，因此一个盘片包括两个磁头。因此有盘片*2个磁头

`柱面`：硬盘是整个计算机系统中很大的瓶颈，因此工程师们想到了并行写入的方式。并行就是指，由多个磁头同时写入，因此这些不同盘面中编号相同的磁道从上到下组成的圆柱体的回转面就称为柱面。

`分区`：是由多个编号连续的柱面组成的，因此分区在物理上的表现是由某段范围内的所有柱面组成的通心环。

分区不能跨柱面，也就是同一个柱面不能包含两个分区，一个柱面只属于一个分区，分区的起始和终止都落在完整的柱面上。

**`分区大小 = 每柱面上的扇区数 * 柱面数 `**

（1）硬盘容量=单片容量×磁头数。
（2）单片容量=每磁道扇区数×磁道数×512 字节。

硬盘容量=每磁道扇区数×柱面数×512 字节×磁头数

![image-20250121205652223](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121205652223.png)

![image-20250121205719225](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121205719225.png)

在硬盘容量已知的情况下：

​	**`柱面数 * 磁头数 = 硬盘容量/63/512` **

分区是**逻辑上**划分磁盘空间的方式，归根结底是人为地将硬盘上的柱面扇区划分为不同的分组。

各区都有“描述符“来描述分区本身所在硬盘上的起止界限等信息，在硬盘的MBR中有64字节"固定大小"的数据结构，这就是著名的分区表。分区表中每一个表项就是一个分区的“描述符”，大小为16字节。

由于受到MBR(`前446字节是硬盘的参数和引导程序以及最后两字节大小的魔数`)大小的限制，在描述符中的属性文件系统**id**。表示文件系统的类型，为支持更多的分区，增加了属性值(id=5),用来表示该分区可以被再次划分出更多的子分区。

所以四个分区中任意一个都可以作为扩展分区，是可选项，最多只有一个。其余的成为主分区。

综上所述，分区表中共 4 个分区，哪个做扩展分区都可以，扩展分区是可选的，但最多只有 1 个，其余的都是主分区。在过去没有扩展分区时，这 4 个分区都是主分区，为了兼容 4 个主分区的情况，扩展分区中的第 1 个逻辑分区的编号从 5 开始。

#### fdisk

旧版是以“柱面”，“磁头”和“扇区” 来描述磁盘布局。

现代都是直接以扇区为单位进行操作。

```bash
欢迎使用 fdisk (util-linux 2.40.4)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0xa66aa100 的新 DOS（MBR）磁盘标签。

命令(输入 m 获取帮助)：p
Disk ./file.img：79.73 MiB，83607552 字节，163296 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xa66aa100

命令(输入 m 获取帮助)：m

帮助：

  DOS (MBR)
   a   开关 可启动 标志
   b   编辑嵌套的 BSD 磁盘标签
   c   开关 dos 兼容性标志

  常规
   d   删除分区
   F   列出未分区的空闲区
   l   列出已知分区类型
   n   添加新分区
   p   打印分区表
   t   更改分区类型
   v   检查分区表
   i   打印某个分区的相关信息
   e   调整分区大小

  杂项
   m   打印此菜单
   u   更改 显示/记录 单位
   x   更多功能(仅限专业人员)

  脚本
   I   从 sfdisk 脚本文件加载磁盘布局
   O   将磁盘布局转储为 sfdisk 脚本文件

  保存并退出
   w   将分区表写入磁盘并退出
   q   退出而不保存更改

  新建空磁盘标签
   g   新建一份 GPT 分区表
   G   新建一份空 GPT (IRIX) 分区表
   o   新建一份的空 DOS（MBR）分区表
   s   新建一份空 Sun 分区表


命令(输入 m 获取帮助)：x

专家命令(输入 m 显示帮助)：m

帮助 (专业命令)：

  DOS (MBR)
   b   移动分区数据的起始点
   F   修复分区 C/H/S 值
   i   更改磁盘标识符

  几何属性（对当前标签）
   c   更改柱面数
   h   更改磁头数
   s   更改扇区/磁道数

  常规
   p   打印分区表
   v   检查分区表
   d   打印设备第1个扇区的原始数据
   D   打印设备磁盘标签的原始数据
   f   修复分区顺序
   m   打印此菜单

  保存并退出
   q   退出而不保存更改
   r   返回主菜单


专家命令(输入 m 显示帮助)：c
柱面数 (1-1048576, 默认 10): 162

专家命令(输入 m 显示帮助)：h
磁头数 (1-255, 默认 255): 16

专家命令(输入 m 显示帮助)：r

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (0个主分区，0个扩展分区，4空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p
分区号 (1-4, 默认  1): 1
第一个扇区 (2048-163295, 默认 2048): 2048
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-163295, 默认 163295): 33263

创建了一个新分区 1，类型为“Linux”，大小为 15.2 MiB。

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (1个主分区，0个扩展分区，3空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：e
分区号 (2-4, 默认  2): 4
第一个扇区 (33264-163295, 默认 34816): 33264
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (33264-163295, 默认 163295): 163295

创建了一个新分区 4，类型为“Extended”，大小为 63.5 MiB。

命令(输入 m 获取帮助)：n
所有主分区的空间都在使用中。
添加逻辑分区 5
第一个扇区 (35312-163295, 默认 36864): 35312
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (35312-163295, 默认 163295): 51407

创建了一个新分区 5，类型为“Linux”，大小为 7.9 MiB。

命令(输入 m 获取帮助)：n
所有主分区的空间都在使用中。
添加逻辑分区 6
第一个扇区 (53456-163295, 默认 55296): 53456
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (53456-163295, 默认 163295): 76607

创建了一个新分区 6，类型为“Linux”，大小为 11.3 MiB。

命令(输入 m 获取帮助)：n
所有主分区的空间都在使用中。
添加逻辑分区 7
第一个扇区 (78656-163295, 默认 79872): 78656
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (78656-163295, 默认 163295): 91727

创建了一个新分区 7，类型为“Linux”，大小为 6.4 MiB。

命令(输入 m 获取帮助)：n
所有主分区的空间都在使用中。
添加逻辑分区 8
第一个扇区 (93776-163295, 默认 94208): 93776
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (93776-163295, 默认 163295): 121967

创建了一个新分区 8，类型为“Linux”，大小为 13.8 MiB。

命令(输入 m 获取帮助)：n
所有主分区的空间都在使用中。
添加逻辑分区 9
第一个扇区 (124016-163295, 默认 124928): 124016
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (124016-163295, 默认 163295): 163295

创建了一个新分区 9，类型为“Linux”，大小为 19.2 MiB。

命令(输入 m 获取帮助)：p
Disk ./file.img：79.73 MiB，83607552 字节，163296 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xa66aa100

设备        启动   起点   末尾   扇区  大小 Id 类型
./file.img1        2048  33263  31216 15.2M 83 Linux
./file.img4       33264 163295 130032 63.5M  5 扩展
./file.img5       35312  51407  16096  7.9M 83 Linux
./file.img6       53456  76607  23152 11.3M 83 Linux
./file.img7       78656  91727  13072  6.4M 83 Linux
./file.img8       93776 121967  28192 13.8M 83 Linux
./file.img9      124016 163295  39280 19.2M 83 Linux

命令(输入 m 获取帮助)：m

帮助：

  DOS (MBR)
   a   开关 可启动 标志
   b   编辑嵌套的 BSD 磁盘标签
   c   开关 dos 兼容性标志

  常规
   d   删除分区
   F   列出未分区的空闲区
   l   列出已知分区类型
   n   添加新分区
   p   打印分区表
   t   更改分区类型
   v   检查分区表
   i   打印某个分区的相关信息
   e   调整分区大小

  杂项
   m   打印此菜单
   u   更改 显示/记录 单位
   x   更多功能(仅限专业人员)

  脚本
   I   从 sfdisk 脚本文件加载磁盘布局
   O   将磁盘布局转储为 sfdisk 脚本文件

  保存并退出
   w   将分区表写入磁盘并退出
   q   退出而不保存更改

  新建空磁盘标签
   g   新建一份 GPT 分区表
   G   新建一份空 GPT (IRIX) 分区表
   o   新建一份的空 DOS（MBR）分区表
   s   新建一份空 Sun 分区表


命令(输入 m 获取帮助)：t
分区号 (1,4-9, 默认  9): 5
Hex 代码或别名（输入 L 列出所有代码）：66

已将分区“Linux”的类型更改为“未知”。

命令(输入 m 获取帮助)：t
分区号 (1,4-9, 默认  9): 6
Hex 代码或别名（输入 L 列出所有代码）：66

已将分区“Linux”的类型更改为“未知”。

命令(输入 m 获取帮助)：t
分区号 (1,4-9, 默认  9): 7
Hex 代码或别名（输入 L 列出所有代码）：66

已将分区“Linux”的类型更改为“未知”。

命令(输入 m 获取帮助)：t
分区号 (1,4-9, 默认  9): 8
Hex 代码或别名（输入 L 列出所有代码）：66

已将分区“Linux”的类型更改为“未知”。

命令(输入 m 获取帮助)：t
分区号 (1,4-9, 默认  9): 9
Hex 代码或别名（输入 L 列出所有代码）：66

已将分区“Linux”的类型更改为“未知”。

命令(输入 m 获取帮助)：p
Disk ./file.img：79.73 MiB，83607552 字节，163296 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xa66aa100

设备        启动   起点   末尾   扇区  大小 Id 类型
./file.img1        2048  33263  31216 15.2M 83 Linux
./file.img4       33264 163295 130032 63.5M  5 扩展
./file.img5       35312  51407  16096  7.9M 66 未知
./file.img6       53456  76607  23152 11.3M 66 未知
./file.img7       78656  91727  13072  6.4M 66 未知
./file.img8       93776 121967  28192 13.8M 66 未知
./file.img9      124016 163295  39280 19.2M 66 未知

命令(输入 m 获取帮助)：w
分区表已调整。

```

逻辑分区柱面范围：

1. 33~50
2. 51~75
3. 75~90
4. 91~120
5. 121~162

## 磁盘分区表浅析

磁盘分区表(Disk Partition Table)简称DPT,是由多个**分区元信息**汇成的表，表中每一个表项都对应一个分区，主要记录各分区的**起始扇区地址，大小界限**等

磁盘分区表就是个数组，此数组长度固定为4,数组元素是分区元信息的结构。

MBR（`Main Boot Record`）即**主引导记录**，它是一段引导程序，其所在的扇区称为**主引导扇区**，该扇区位于 **0 盘 0 道 1 扇区**（物理扇区编号从 1 开始，逻辑扇区地址 LBA 从 0 开始） ，也就是硬盘最开始的扇区，扇区大小为 512 字节，这 512 字节内容由三部分组成:

* 主引导记录MBR
* 磁盘分区表DPT
* 结束魔数55AA,表示此扇区为主引导扇区，里面包含控制程序

**MBR 引导程序**位于主引导扇区中偏移 0～0x1BD 的空间，共计 **446** 字节大小，这其中包括**硬盘参数
及部分指令**（由 BIOS 跳入执行），它是由分区工具产生的，独立于任何操作系统。

**磁盘分区表**位于主引导扇区中偏移 0x1BE～0x1FD 的空间，总共 **64** 字节大小，每个分区表项是 16
字节，因此磁盘分区表最大支持 4 个分区。
**魔数 55AA** 作为主引导扇区的有效标志，位于扇区偏移 0x1FE～0x1FF，也就是**最后 2 个字节。**

![image-20250121223354124](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121223354124.png)

由于柱面不能跨磁道(同一个磁道不能被多个分区共享)，MBR占了第0块，因此分区起始地址要偏移磁盘一个磁道大小。

对于不够一个柱面的剩余的空间一般不再利用，并不参与分区。除去 MBR 引导扇区占用的 1 扇区，这部分剩余空间是 62 个扇区。

为了扩展分区以及向上兼容：

* 视这个扩展分区为总扩展分区，将它划分为多个子扩展分区
* 每个子扩展分区"在逻辑上"相当于硬盘
* 因此每个子扩展分区都可以有一个分区表

因此理论上有无限分区表

用链表来组织这些信息，链表结点就是分区表，表项两部分：

1. 描述逻辑分区的信息
2. 下一个子扩展分区的地址

逻辑分区也是分区，也需要有元信息来描述它的范围、边界、类型等信息，因此在子拓展分区中也要有分区表来描述这些逻辑分区。分区表本身也要在子拓展分区占空间。

因此在每个子扩展分区最开始的扇区(EBR引导扇区)用于存储子扩展分区中的分区表。

由于子扩展分区在逻辑上也相当于单独的硬盘，因此各分区表在各个子扩展分区最开始的扇区中，同MBR引导扇区结构相同。由于是经扩展分区划分出来的，因此称为**`EBR`，即扩展引导记录**。

 EBR 中分区表的**第一分区表项**用来描述所包含的**逻辑分区的元信息**，第二分区**表项用来描述下一个子扩展分区的地址**，第三、四表项未用到。位于 EBR 中的分区表相当于链表中的结点，第一个分区表项存的是分区数据，第二个分区表项存的是后继分区的指针。

第一个表项指向的是该逻辑分区最开始的扇区，此扇区称为**操作系统引导扇区，及OBR(OS Boot Record)引导扇区**。第二个指向下一个子扩展分区的EBR引导扇区。

![image-20250121225845070](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121225845070.png)

MBR和EBR与OBR最大的区别就是:**OBR中没有分区表**.

MBR 和 EBR 所在的扇区不属于分区范围之内，它们是由分区工具创建并管理的，因此不归操作系统管理，操作系统不可以随意往里面写数据，尽管操作系统有能力这样做。

而 OBR 引导扇区是分区中最开始的扇区，归操作系统的文件系统管理，因此操作系统通常往 OBR 引导扇区中添加内核加载器的代码，供 MBR 调用以实现操作系统自举，总之 OBR 引导扇区中绝对不包括分区表。

![image-20250121230526544](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121230526544.png)

![image-20250121231000458](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121231000458.png)

![image-20250121232050967](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121232050967.png)

![image-20250121232957255](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121232957255.png)

![image-20250121233020261](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121233020261.png)

![image-20250121233035728](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250121233035728.png)

## 编写硬盘驱动程序

驱动程序是对硬件接口的封装，把参数设置等重复、枯燥、复杂的过程封装成一个过程，在硬件操作更加的容易、省事、方便。

### 硬盘初始化

硬件是实实在在的东西，要想在软件中管理它们，只能从**逻辑上**抓住这些硬件的特性，将它们**抽象成一些数
据结构**，然后这些数据结构便代表了硬件，用这些数据结构来**组织硬件的信息及状态**，在逻辑上硬件就是这数据结构

支持硬盘操作：

* 硬盘有两ata通道，也称为IDE通道
* 第一个的两个硬盘(主和从)的中断挂在`8259A`从片上的IRQ14上
* 第二个接在`8259A`从片的IRQ15上。

两个硬盘共享同一个IRQ接口，对硬件**执行**某些命令，硬盘**完成任务后才发中断**，对硬盘发命令时，需要**提前指定**是对主盘还是从盘。

来自`8259A`从片的中断是有`8259A`主片帮忙向处理器传达的，从片级联在主片的IRQ2接口。

通道的端口基址，这里处理两个通道的主板，每个通道的端口范围不一样：

通道一(Primary 通道)：命令块寄存器端口范围是0x1F0~0x1F7,控制块寄存器端口0x3F6

通道二(Secondary通道)：命令块寄存器端口范围是0x170~0x177,控制块寄存器端口是0x376

通道 1 的端口可以**以 0x1F0 为基数**，其**命令块寄存器端口**在此基数上分别加上**0～7** 就可以了，
**控制块寄存器端口在此基数上加上 0x206，同理，通道 2 的基数就是 0x170。**

### 实现thread_yield和idle线程

`thread_yield`的功能是：主动把CPU使用权让出来，它与`thread_block`的区别是`thread_yield`执行后任务的状态是**TASK_READY**,即让出CPU后就会被加入到就绪队列中。而`thread_block`执行后的任务状态是**TASK_BLOCKED**，需要被唤醒后才能加入到就绪队列.

idle线程用于系统空闲时，也就是就绪队列中没有任务时才运行的。

在函数体中执行"thread_block(TASK_BLOCKED)"阻塞自己，在被唤醒后，通过内联汇编执行`hlt`指令，使系统挂起，达到真正的空闲。但必须保证在开中断的情况下。

处理器需要被唤醒，必须要保证在开中断的情况下执行 hlt，因此内联汇编代码中，先执行 sti，再
执行 hlt。顺便说一下，idle_thread 在第一次创建时会被加入到就绪队列，因此会执行一次，然后阻塞。

### 实现简单的休眠函数

转换成滴答数，不管休眠的时间粒度是毫秒还是更大，最终都要转换成中断次数。

### 完善硬盘驱动程序

读写扇区数端口**0x1f2及0x172是8位寄存器**，故每次读写最多是255个扇区，因此当读写的端口数超过256时，必须拆分成多次读写操作。

中断处理**完成后**，需要**显式通知**硬盘控制器此次中断已经处理完成，否则硬盘便**不会产生新的中断**，这也是为了保证数据的有效性和安全性。硬盘控制器的中断在下列情况下会被清掉：

* 读取了status寄存器
* 发出了reset命令
* 或者又向reg_cmd写入了新的命令

我们采取的是第一种方法，再读取一次status寄存器

### 获取硬盘信息，扫描分区表

1. 向硬盘发`identify`命令获取硬盘的信息
2. 扫描分区表

`identify`命令是**0xec**，用于获取硬盘的参数，此命令返回的结构都是**以字为单位**。

![image-20250122221747918](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250122221747918.png)

![image-20250122221958113](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250122221958113.png)

本地对应的分别是`kernel.img`和`file.img`

