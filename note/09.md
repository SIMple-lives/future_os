# 线程

## 实现内核线程

### 执行流

过去，计算机只有一个处理器(现在一般是8核)，在其上运行的系统也是单任务操作系统，即不管有多少任务，任务的执行都是串行的，一个任务彻底执行完成后才能开始下一个任务.

在处理器不变的情况下，出现了多任务操作系统，采用了一种多道程序设计方式，使得处理器在所有任务之间来回切换，称为"伪并行".

![image-20250113163647910](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113163647910.png)

在一个处理器上，要兼顾所有的任务，唯一的做法是只能让每个人物各在处理器上执行一小会儿，然后换下一个任务上处理器。

**任务调度器**：操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。

**调度器**在内核中维护一个任务表(进程、线程、调度表)，按照一定算法。从表中**选择**一个任务，将该任务**放上**处理器上运行，当**任务时间片到期后**，找另外一个任务放上处理器上运行.

![image-20250113175254126](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113175254126.png)

处理器原生支持"任务"并提供了相关的结构、方法：`TSS`结构和任务门。

我们把程序计数器中的下一条指令地址所组成的执行轨迹所组成的执行轨迹称为程序的控制执行流。

**执行流**就是一段逻辑上**独立的指令区域**，是人为给**处理器安排的处理单元**。指令是**具备“能动性”的数据**，因此只有指令才有“执行”的能力，它相当于是**动作的发出者**，由它**指导处理器**产生相应的行为。指令是由处理器来执行的，它**引领**处理器“前进”的方向，用“流”来表示处理器中程序计数器的航向，借此比喻处理器依次把此区域中的指令执行完后，所形成的像河流一样曲直不一的执行轨迹、执行路径（由顺序执行指令及跳转指令导致）。

执行流对应于代码，大到可以是整个程序文件，即**进程**，小到可以是一个功能独立的代码块，即函数，而**线程**本质上就是函数。

执行流的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源。

在任务调度器的眼里，只有**执行流**才是调度单元，即处理器上运行的每个任务都是调度器给分配的执行流，只要成为执行流就能够独立上处理器运行了。

我们软件中所做的**任务切换**，本质上就是改变了**处理器中程序计数器的指向**，即改变了处理器的“执行流”。
任务只是人为划分的、逻辑上的概念，人们把一个个的**执行单元**称为任务，我们所说的执行单元就是这些彼此独立的**执行流**，因此，独立的执行流成了调度器的调度单元，并使之成为了处理器的基本执行单位。

### 线程是什么

![image-20250113181540392](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113181540392.png)线程是一套**机制**，此机制可以为一般的代码块**创造它所依赖的上下文环境**，从而让**代码块具有独立性**，因此在原理上**线程**能使一段**函数**成为**调度单元**（或称为执行流)，使函数能被调度器“认可”，从而能够被**专门**调度到**处理器上执行**。这样，函数就可以被**加入**到线程表中作为调度器的调度单元，从而有机会**单独获得处理器资源**，也就是说，处理器不是把线程中**调用的函数**和其线程的作用他指令**混在一块执行**的，或者说不是在执行整个进程时顺便执行了该函数，而是单独、专门执行了此函数

当函数可以独立运行时，就可以让程序中的多个函数(执行流)以并行的方式运行(当然是伪并行)，为程序提速

### 进程与线程的关系、区别

对于处理器来说，**进程**是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是**处理器的执行单位**，或者称为调度单位，它们就是**线程**。

进程拥有整个地址空间，从而拥有全部资源，线程没有自己的地址空间，因此没有任何属于自己的资源，需要借助进程的资源“生存” ，所以线程被称为轻量级进程（照理说，进程被称为重量级线程也未尝不可） 。进程和线程都是执行流，它们都具备独立寄存器资源和独立的栈空间，因此线程也可以像进程那样调用其他函数。



进程采用多个执行流和其他进程抢处理器资源，这样就节省了单个进程的总执行时间。

另一个提速的原理就是避免阻塞整个进程。

![image-20250113184035775](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113184035775.png)

进程与线程的关系是资源容器，线程是资源的使用者。线程没有自己的独享的资源，因此没有自己的地址空间，他要依附在进程的地址空间从而借助进程的资源运行。

线程没有自己的页表，而进程拥有。

### 进程、线程的状态

操作系统把进程**”执行过程“**中所经历的不同阶段按状态归为几类。

* 需要等待外界条件的状态称为”阻塞态“
* 外界条件成立时，进程可以随时准备运行的状态称为”就绪态“
* 正在处理器上运行的进程的状态称为"运行态"

![image-20250113185223349](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113185223349.png)

### 进程的身份证--PCB

操作系统为每个进程提供了一个**`PCB，Process Control Block`**，即程序控制块。

每个进程都有自己PCB,所有PCB放到一张表格中维护，这就是进程表。调度器根据根据进程表中选择上处理器运行的进程。

![image-20250113190130846](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113190130846.png)

![image-20250113185812203](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113185812203.png)

`寄存器映像`用来解决第四个问题，即保存进程的"现场"，进程在处理器上运行时，所有寄存器的值都将保存到此处。第二个问题也一同解决，从PCB中把寄存器映像加载到寄存器中就行。

![image-20250113191013538](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113191013538.png)

### 实现线程的两种方式--内核或用户进程

线程仅仅是一个执行流，在用户空间还是在内核空间实现它，最大的区别就是线程表在那里，由谁来调度它上处理器。

#### 在用户空间中实现线程

好处：移植性强

![image-20250113191649464](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113191649464.png)

用户进程中实现线程的优点：

* 可以根据实现应用情况为某些线程加权调度
* 寄存器映像装载到CPU时，可以在用户空间完成，不用陷入内核态，免去了入栈及出栈操作

缺点：

* 某个线程出现阻塞，操作系统不知道进程中存在线程，因此会将整个进程挂起
* 未实现在内核当中，对操作系统来说、调度器的调度单元是整个进程，并不是进程中的线程，时钟中断只能影响进程一级的执行流。当中断发生后，操作系统要么将处理器交给进程A,要么进程B,不会给某一个线程。
* 减少了内部调度陷入内核状态的时间，但整个进程的执行时间有限，线程执行的时间会更加短暂，还要在进程内维护线程表、运行调度算法

#### 在内核空间实现线程

内核提供原生线程机制。

优点：

* 内核提供的线程让进程多占用了处理器资源
* 线程阻塞后会调用其他线程

缺点：

* 用户需要通过系统调用陷入内核，增加了一些现场保护的栈操作。

## 在内核空间实现线程

```c
struct thread_stack {
    uint32_t ebp;
    uint32_t ebx;
    uint32_t edi;
    uint32_t esi;

    /* 线程第一次执行时,eip指向待调用的函数kernel_thread
   其它时候,eip是指向switch_to的返回地址*/
    void (*eip) (thread_fun *func,void *func_arg);

    /*****   以下仅供第一次被调度上cpu时使用   ****/

    /* 参数unused_ret只为占位置充数为返回地址 */
    void (*unused_retaddr);        //第一次被调度上cpu时,返回地址
    thread_fun* function;          // 由kernel_thread所调用的函数名
    void* func_arg;                //有kernel_thread所调用的函数参数
};
```

主要体现在在成员**`EIP`**上：

1. 线程肯定得知道要运行那个函数，首次执行某个函数时候，这个栈就用来保持待运行的函数，其中eip便是该函数的地址
2. 将来使用switch_to函数实现任务切换，当任务切换时，用来保存任务切换后的新任务的返回地址

前四个涉及到了ABI的内容，`ABI`是`Application Binary Interface`,即应用程序二进制接口。

`API`，`API`是`Application Programming Interface`,即应用程序可编程接口。

c编译器按照这套ABI规则来编译c程序。因此，如果要自己手动写汇编函数，并且此函数要供c语言调用的话，咋们也得按照ABI的规则去写汇编才行。

![image-20250113205921951](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250113205921951.png)

在c层面，函数的执行都是由调用者发起调用的，通过`call`指令完成，此指令会在栈中留下返回地址。因此被调用函数在执行时，会认为调用者已经把返回地址留在栈中，而且是在栈顶的位置。

## 核心数据结构

**程序=算法+数据结构**

双向链表，要注意的是更改数据时要保证原子操作，关闭中断，相关数据处理完成后在恢复。

## 多线程调度

ticks和上面的priority配合使用，priority表示任务的优先级，优先级体现在任务执行的时间片上，即优先级越高，每次任务被调度上处理器后执行的时间片就越长。当ticks递减为0时，被时间中断处理程序和调度器换下处理器，调度器将priority重新给ticks.

![image-20250114141246761](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114141246761.png)

###  任务调度器和任务切换

调度器主要任务就是读写就绪队列。根据任务的状态将其从处理器上换上换下。

调度器是从就绪队列`thread_ready_list`中“取出”上处理器运行的线程，所有待执行的线程都在`thread_ready_list`中，我们调度机制很简单，就是**`Round-Robin Scheduling`**,俗称**RR**，即**轮询调度**。

就是让候选线程按顺序一个一个地执行，按先进先出的顺序始终调度队头的线程。

另外注意的是在`thread_ready_list`中的线程状态都是`TASK_READY`而运行的线程状态`TASK_RUNNING`是在`thread_all_list`中。

完整的调度过程需要三部分的配合：

1. 时钟中断处理函数
2. 调度器schedule
3. 任务切换函数switcho

* 注册时钟处理函数
* 实现调度器schedule
* 实现任务切换函数switch_to

任务与任务的区别在于**执行流一整套的上下文资源**，这包括寄存器映像、地址空间、IO 位图等，在将来介绍任务状态段 TSS 之后，您就会了解这套上下文资源恰恰就是 TSS 结构中的内容，**拥有这些资源才称得上是任务。**

### 保护任务的上下文

每个**任务都有执行流**，这都是事先规划好的执行路径。实际情况执行流会被**打断或者改道**，每一次中断都会使处理器放下当前任务去**执行**中断处理程序。为了处理完中断后能够**恢复任务**的原有执行路径，必须在执行流**改变**前将任务的上下文保护好。

![image-20250114151258865](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114151258865.png)

任务调度由时钟中断发起，由中断处理程序调用switch_to函数实现。

假设当前任务在**中断发生前**所处的执行流**属于第一层**，受时钟中断的影响，处理器会进入中断处理程序，这使得**当前的任务执行流第一次被改变**，进入中断前，保护好第一层的上下文。

之后在执行中断处理程序，这属于**第二层执行流**，当中断处理程序调用任务切换函数`switch_to`时，当前中断处理又要被中断，因此需要保护好第二层的上下文。

![image-20250114151914184](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114151914184.png)

总结：
（1）上下文保护的第一部分负责保存任务进入中断前的全部寄存器，目的是能让任务恢复到中断前。
（2）上下文保护的第二部分负责保存这 4 个寄存器：esi、edi、ebx 和 ebp，目的是让任务恢复执行在
任务切换发生时剩下尚未执行的内核代码，保证顺利走到退出中断的出口，利用第一部分保护的寄存器环
境彻底恢复任务。

switch_to 到这就结束了，它略微有些难懂，这主要体现在。
（1）switch_to 的操作对象是线程栈 struct thread_stack，对栈中的返回地址及参数的设置可能会感觉
有点糊涂。因此建议别只看局部，从全局上看 kernel.S、interrupt.c、timer.c、thread.c，它们之间是密切
配合的。
（2）上下文的保护工作分为两部分，第一部分用于恢复中断前的状态，这相对好理解。咱们的函数
switch_to 完成的是第二部分，用于任务切换后恢复执行中断处理程序中的后续代码。

![image-20250114174309566](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250114174309566.png)

插入时间点断点的命令是**sba**。
