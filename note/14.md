# 文件系统

## 文件系统概念简介

### inode、间接块索引表、文件控制块FCB简介

块是文件系统的读写单位，块是由多个扇区组成的，块大小是扇区大小的整数倍。

FAT文件系统：FAT称为文件分配表，在文件系统中存储的文件，其所有的块**被用于链式结构**来组织，在每个块的最后**存储下一个块**的地址，从而块与块之间串联到一起。

![image-20250123152028619](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123152028619.png)

图中A大小为10,块大小是4,因此要占用三个块。但通过链式结构来组织文件的弊端就是**当访问文件中的某个块时，必须要从头开始便利块结点**

FAT文件系统中的每个文件都有这么个单独的链式结构来组织、跟踪文件的所有块。



UINX操作系统中的索引结构--inode.UINX文件系统将**文件**以**索引结构**来组织，避免访问某一数据块需要遍历所有块的缺点。

索引结构文件系统的优点：

* 分散到不连续的空间中、保留了磁盘高利用率的优点
* 为每个文件的所有块建立了一个索引表,访问速度提升

索引表就是块地址数组，每个数组元素就是块的地址，数组元素下标是文件块的索引。

包含此索引表的索引结构称为`inode`，即`index node`，索引结点，用来索引、跟踪一个文件的所有块。

**inode 是文件索引结构组织形式的具体体现，必须为每个文件都单独配备一个这样的元信息数据结构， 因此在UINX 文件系统中， 一个文件必须对应一个inode， 磁盘中有多少文件就有多少inode。**

![image-20250123175708701](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123175708701.png)

缺点是索引表本身要占用一定的存储空间，文件很大时，索引表所占的存储空间也增大。

![image-20250123180324010](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123180324010.png)

只要用于管理、控制文件相关信息的数据结构都被称为`FCB(File Contrl Block)`,即文件控制块，`inode`也是这种结构，因此inode是FCB的一种。

![image-20250123181453829](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123181453829.png)

### 目录项与目录简介

 文件系统是如何把文件名和`inode`关联到一起？

在Linux中，目录和文件都用`inode`来表示，因此目录也是文件，只是目录包含文件。

`inode`即可以表示目录，又可以表示普通文件。因此数据块本身的内容用来区分目录与普通文件。

目录路相当于个文件列表，每个**文件在目录**中都是一个`entry`(条目、项)，各个`entry`中的内容包括**文件名、文件类型，inode编号**，这个`entry`是目录中各个文件的描述，它称为目录项。

![image-20250123201038064](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123201038064.png)

作用：

* 标识此Inode表示的文件是目录，还是普通文件
* 将文件名与inode做个绑定关联

通过文件实体数据块的流程是：

1. 在目录中找到文件名所在的目录项
2. 在目录项中获取inode编号
3. 用inode编号作为`inode`数组的索引下标，找到`inode`
4. 从该`inode`中获取数据块的地址，读取数据块

创建文件的本事是创建文件的文件控制块。

总结：

1. 每个文件都有自己**单独的 inode**，inode 是文件**实体数据块**在文件系统上的**元信息**。
2. 所有文件的 inode 集中管理，形成 inode 数组，每个 inode 的编号就是在该 inode 数组中的下标。
3. inode 中的**前 12 个直接数据块指针**和**后 3 个**间接块索引表用于指向文件的**数据块实体**。
4. 文件系统中并不存在具体称为“目录”的数据结构，同样也没有称为“普通文件”的数据结构，统一用同一种 inode 表示。inode 表示的文件是普通文件，还是目录文件，取决于 **inode 所指向数据块中的实际内容**是什么，即数据块中的内容要么是普通文件本身的数据，要么是目录中的目录项。
5. 目录项仅存在于 inode 指向的数据块中，有**目录项的数据块就是目录**，目录项所属的 **inode 指向的所有数据块便是目录**。
6. 目录项中记录的是文件名、文件 inode 的编号和文件类型，目录项起到的作用有两个，一是粘合文件名及 inode，使文件名和 inode 关联绑定，二是标识此 inode 所指向的数据块中的数据类型（比如是普通文件，还是目录，当然还有更多的类型）。
7. inode 是文件的“实质”，但它并不能直接引用，必须通过**文件名找到文件名所在的目录项**，然后从该目录项中获得 inode 的编号，然后用此编号到 inode 数组中去找相关的 inode，最终找到文件的数据块。

![image-20250123202250508](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123202250508.png)

### 超级块与文件系统布局

**超级块**是保存文件系统元信息的元信息。(相当于文件系统的配置文件)

我们也用位图来管理`inode`的使用情况，因此又一个元信息，inode位图.

总结：简易文件系统需要：

* `inode`数组的地址及大小
* `inode`位图地址及大小
* 根目录的地址和大小
* 空闲块位图的地址和大小

![image-20250123213800021](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123213800021.png)

**魔数**用来确定文件系统类型的标志，用它来**区别于**其他文件系统。

超级块是为分区创建文件系统时创建的，所有有关文件系统元信息的配置都在超级块中，因此超级块的**位置和大小**不能再被配置，必须是固定的，它被**固定在各分区的第二个扇区**，通常是占用**一个扇区的大小**。

![image-20250123214329567](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250123214329567.png)

`操作系统引导块`就是曾经介绍过的**操作系统记录引导OBR所在的地址**。

除了`根目录`和`空闲块区域`是真正用于存储数据的区域，其余部分占用的扇区数取决于分区容量大小，或创建时手动设置。

## 创建文件系统

在此实现中数据块大小与扇区大小一致，即1块等于1扇区。

创建文件系统就是创建**文件系统所需要的元信息**，包括：

* 超级块位置及大小
* 空闲块位图的位置及大小
* inode位图的位置及大小
* inode数组的位置及大小
* 空闲块起始地址
* 根目录起始地址

创建步骤：

1. 根据分区part大小，计算分区文件系统各元信息需要的扇区数及位置
2. 在内存中创建超级块，将以上步骤计算的元信息写入超级块
3. 将超级块写入磁盘
4. 将元信息写入磁盘上各自的位置
5. 将根目录写入磁盘

**挂载分区**：

`Linux`内核所在的分区是默认分区，自系统启动后就以该分区为默认分区，该分区的根目录是固定存在的。

挂载分区的实质就是把该分区文件系统的元信息从硬盘上读出来加载到内存中，这样硬盘资源的变化都用**内存中元信息**来跟踪，如果有写操作，及时将内存中的元信息同步写入到硬盘**以持久化**。

## 文件描述符简介

文件描述符即`file descriptor`，所描述的对象是文件。

Linux提供了称为"文件结构"的数据结构，专门用于记录与**文件操作**相关的信息，每次打开一个文件就会产生一个文件结构，**多次打开**该文件就为该文件生成**多个文件结构**。

![image-20250124202337033](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250124202337033.png)

在Linux中每个进程都有**单独的、完全相同的一套文件描述符**，因此与其他进程的文件描述符互不干涉。

由于每打开一个文件就会产生一个文件结构，如果同时打开过多，文件表占用内存过大，这就是进程可打开的**最大文件数**有限的原因。

文件描述符为什么是数字？

1. 使各进程可打开的文件数是一样的，各进程必须有**独立的、大小完全一样**的一套文件描述符数组，而不能`共享`同一套文件描述符。
2. 文件结构中包含进程执行文件操作的偏移量，它属于与各个人物单独绑定的资源，因此最好放在PCB中管理。

基于上述两个原因，一般在`PCB`中建立文件描述符数组，该数组成员不需要是真正的文件结构，出于简单处理，用int来存储文件表中文件结构的下标。

因此当用户进程打开文件时，文件系统给用户返回的是该进程`PCB`中文件描述符数组下标值，也就是文件描述符。

![image-20250124204104333](https://raw.githubusercontent.com/SIMple-lives/future_os/main/img/image-20250124204104333.png)

通过文件描述符查找文件数据块的过程，以下是涉及到的数据结构，均位于内存中

* PCB中的文件描述符数组
* 存储所有文件结构的文件表
* inode队列，也就是inode缓存

过程：

1. 进程将**文件描述符**作为**参数传入**
2. 文件系统用此描述符在该**进程的PCB中的文件描述符数组索引**
3. 从而**获取到文件inode**
4. 最终找到数据块。

## 文件操作相关的基础函数

## 创建文件

创建文件的工作：

1. 文件需要inode来描述大小、位置等属性，所以在创建文件时就要创建其inode。涉及向inode_bitmap申请位图来获得inode号，inode——bitmap会被更新，inode_table数组中的某项也会由新的inode填充
2. inode->i_sectors是文件存储的扇区地址，需要向block_bitmap申请可用位来获得可用的块，分区的数据区data_start_lba以后的某个扇区被分配
3. 某个目录的inode->i_size会增加个目录项的大小，新增的文件对应的目录项需要写入该目录的inode_i_sectors[]中的某个扇区
4. 若某一步操作失败，需要回滚操作
5. 内存中更改的数据需要同步到硬盘中。

创建文件顺序：创建文件i结点--->文件描述符fd--->目录项

```c
open(const char* pathname, (O_CREAT|O_WRONLY|O_TRUNC));
```

## 文件的打开与关闭

![image-20250125233355053](/home/future/.config/Typora/typora-user-images/image-20250125233355053.png)

栈区内存不够、需要到堆区去开辟一块内存来存储该临时变量。

根据报错信息来看，UD问题出现在创建文件的时候，创建文件调用的是`sys_open()`函数，通过对该函数的追踪，发现问题所在是:

```c
char name[MAX_FILE_NAME_LEN] = {0};
```

那问题就可能是栈区溢出导致了无效错误。

后面经过不断测试发现由于是自我实现的操作系统，所以不支持

```c
char name[MAX_FILE_NAME_LEN] = {0};
```

不支持为字符数组赋值的操作，并不是栈区存储的问题，是赋值导致了`bochs`的无效操作。

## 实现文件读写指针定位功能

```c
off_t lseek(int fd, off_t offset, int whence);
//offset偏移量， whence参照物
```

SEEK_SET，offset 的参照物是文件开始处，也就是将读写位置指针设置为距文件开头偏移 offset 个字节处。
SEEK_CUR，offset 的参照物是当前读写位置，也就是将读写位置指针设置为当前位置+offset。
SEEK_END，offset 的参照物是文件尺寸大小，即文件最后一个字节的下一个字节，也就是将读写位置指针设置为文件尺寸+offset。

## 实现文件删除功能

删除文件最重要的就是回收文件对应的`inode`，与`inode`相关的资源：

1. inode位图
2. inode_table
3. inode中i_sectors[0~11]中的直接块和一级间接索引块表i_sectors[12]中的间接块
4. 一级间接索引块表本身的扇区地址

文件名是以目录项的形式存在的，删除文件必须在目录中将其目录项擦除。删除目录项的相关工作：

1. 在文件所在的目录中擦出该文件的目录项，使其为0
2. 根目录是必须存在的，他是文件读写的根基，不应该被清空，它至少要保留一个块。如果目录项独占一个块，并且该块不是根目录最后一个块的话，将其回收
3. 目录inode的i_size是目录项大小的综合，因此还要将i_size减去一个目录项的单位大小
4. 目录inode改变后，要同步到硬盘

## 创建目录

```c
int mkdir(const char* pathname, mode_t mode);
//path是待创建的目录名，mode是所创建目录的权限
```

创建目录所设计的工作

1. 确认待创建的新目录在文件系统上不存在
2. 问新目录创建inode
3. 为新目录分配一个块存储该目录中的目录项
4. 在新目录中创建两个目录项"."和".."，这是每个目录都必须存在的两个目录项
5. 在新目录的父目录中添加新的目录项
6. 将以上资源的变更同步到硬盘

## 遍历目录

遍历目录就是读取目录中所有的目录项，在便利之前要把目录打开，之后还需要把目录关闭。

## 删除目录

删除目录是目录操作最基本的功能，除此之外实现`目录回绕`。

```c
//在inode编号p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字
//将名字存入缓冲区path,成功返回0,失败返回-1
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf) {
    struct inode* child_dir_inode = inode_open(cur_part, c_inode_nr);
    
    // 读取子目录的第一个扇区
    uint32_t first_block = child_dir_inode->i_sectors[0];
    if (first_block == 0) {
        inode_close(child_dir_inode);
        return -1; // 没有有效的扇区
    }
    
    // 读取该扇区的目录项
    ide_read(cur_part->my_disk, first_block, io_buf, 1);
    struct dir_entry* dir_e = (struct dir_entry*) io_buf;
    
    // 遍历目录项，查找'.'目录项
    uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
    uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
    
    for (int i = 0; i < dir_entrys_per_sec; i++) {
        if (strncmp((dir_e + i)->filename, ".", 1) == 0) {
            // 找到'.'目录项
            strcat(path, "/");
            strcat(path, (dir_e + i)->filename);
            inode_close(child_dir_inode);
            return 0; // 返回当前目录名称
        }
    }
    
    inode_close(child_dir_inode);
    return -1; // 没有找到
}

```

书中思路是通过打开父目录的inode,获取到`p_inode_nr`的目录中的所占的扇区块，通过遍历所有的块，遍历每个块中的目录项来获取到`c_inode_nr`的名称信息。

上述代码是我的一种思路：

1. 直接打开`c_inode_nr`对应的inode
2. 通过读取该inode的第一扇区
3. 获取到第一扇区中的目录项'.'
4. 读取该目录项的名称

```c
char* getcwd(char* buf, size_t size);
```

## 获得文件属性

```c
int stat(const char* path, struct stat* buf);
```

