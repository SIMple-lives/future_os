# 保护模式入门

（1）实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。
（2）用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地
指哪打哪。
（3）用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。
以上 3 个原因属于安全缺陷，没有安全可言的 CPU 注定是不可依赖的，这从基因上决定了用户程
序乃至操作系统的数据都可以被随意地删改，一旦出事往往都是灾难性的，而且不容易排查。
（4）访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。
（5）一次只能运行一个程序，无法充分利用计算机资源。
（6）共 20 条地址线，最大可用内存为 1MB，这即使在 20 年前也不够用。

---

**除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的16位拓展到了32位。**

![image-20241107201139253](/home/future/.config/Typora/typora-user-images/image-20241107201139253.png)

图下面的6个段寄存器，依然是16位、是为了向下兼容实模式

偏移地址还和实模式下的一样，但**段基址**可不是简单的一个地址的事了。为了更加安全，怎么也得多添加点**约束条件**才靠谱。这些“约束条件”便是对**内存段的描述信息**。由于信息太多了，肯定用一个寄存器是放不下了，所以专门找了个数据结构—**全局描述符表**。既然叫表，就说明里面有表项，表中至少有一个表项，其中每一个表项称为**段描述符**，其大小为 **64 字节**，用来描述各个内存段的起始地址、大小、权限等信息（由于本节不是在讨论全局描述符表，故这部分会在以后章节中细说） 。该全局描述符表很大，所以放在了内存中，由 GDTR 寄存器指向它就行。

## 段描述符缓冲寄存器

1. 段描述符是在内存中，访问内存对 CPU 来说是比较慢的动作，效率不高。
2. 段描述符的格式很奇怪，一个数据要分三个地方存，所以 CPU 要把这些七零八落的数拼合成一个完整数据也是要花时间的。

针对以上两个问题，对段寄存器采用了缓存技术，将段寄存器使用一个寄存器来缓存

![image-20241107202839610](/home/future/.config/Typora/typora-user-images/image-20241107202839610.png)

CPU三种模式:

* 实模式
* 虚拟8086模式
* 保护模式

## 保护模式寻址

保护模式下、基址寄存器不再只是`bx、bp`，而是所有32位的通用寄存器

变址寄存器也不再只是`di、si`，而是除`esp`外的所有32位的通用寄存器

![image-20241107210758144](/home/future/.config/Typora/typora-user-images/image-20241107210758144.png)

## 保护模式之运行模式反转

由于在两种模式下、同样的操作码和操作数编码，都有着不同的解释。

所以在指令的最前面有一个前缀字段，用来告诉CPU应用此指令的模式。

总结：

* `bits`伪指令用于指定运行模式
* 操作数大小反转前缀0x66
* 寻址方式反转前缀0x67

后两个用于临时将当前模式下的操作数大小和寻址方式转变为另外一种模式。



## 保护模式之指令拓展

下面两个指令，为了支持32位操作数，不得不增加了额外的寄存器

### mul

`mul`是无符号数相乘指令,格式为`mul 寄存器/内存`

如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。
如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。
如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积
的高 32 位，eax 是积的低 32 位。

### div

对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。
如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。
如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于
寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。
如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于
寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

## 全局描述符表

**`全局描述符表（Global Descriptor Table,GDT)`**是保护模式下内存段的登记表。

![image-20241108172122117](/home/future/.config/Typora/typora-user-images/image-20241108172122117.png)

段界限边界值=（描述符中段界限+1）*（段界限的粒度大小：4KB 或者 1）-1。

![image-20241108174610722](/home/future/.config/Typora/typora-user-images/image-20241108174610722.png)

### 全局描述符表GDT、局部描述符表LDT及选择子

全局描述符GDT相当于是描述符的数组，数组中的每一个元素都是8字节的描述符。

`全局`体现在多个程序都可以在里面定义自己的段描述符。

#### GDTR

**全局描述符表位于内存中，有专门的寄存器`GDTR`即GDT Register，专门用来存储GDT的内存地址及大小。是一个48位的寄存器**

![image-20241109192518835](/home/future/.config/Typora/typora-user-images/image-20241109192518835.png)

对于此寄存器的访问不能使用`mov gdtr`这样的指令为gdtr初始化，有专门的**lgdt**指令

lgdt的指令格式为`lgdt 48位内存数据`

这 48 位内存数据划分为两部分，其中前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于GDT 的字节大小减 1。后 32 位是GDT的起始地址。由于 GDT 的大小是 16 位二进制，其表示的范围是 2的 16 次方等于 65536 字节。每个描述符大小是 8 字节，故GDT 中最多可容纳的描述符数量是 65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

#### 选择子

段寄存器 CS、DS、ES、FS、GS、SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。而在保护模式下时，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西—selector

![image-20241109193551077](/home/future/.config/Typora/typora-user-images/image-20241109193551077.png)

#### 局部描述符表

CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是 LDT，即每个任务
都有自己的 LDT，随着任务切换，也要切换相应任务的 LDT。LDT 也位于内存中，其地址需要先被加载
到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR，即 LDT Register。同样也有专门的指令用于加
载 LDT，即 lldt。以后每切换任务时，都要用 lldt 指令重新加载任务的私有内存段。
回顾一下段描述符中的 type 字段，其中 LDT 为系统段，换句话说，LDT 虽然是个表，但其也是一片内存
区域，所以也需要用个描述符在 GDT 中先注册。段描述符是需要用选择子去访问的。故，lldt 的指令格式为：
lldt 16 位寄存器/16 位内存
无论是寄存器，还是内存，其内容一定是个选择子，该选择子用来在 GDT 中索引 LDT 的段描述符。
在 LDT 被加载到 ldtr 寄存器后，之后再访问某个段时，选择子中的 TI 位若为 1，就会用该选择子中
的高 13 位在 ldtr 寄存器所指向的 LDT 中去索引相应段描述符。
LDT 中的段描述符和 GDT 中的一样，与 GDT 不同的是 LDT 中的第 0 个段描述符是可用的，因为提
交的选择子中的 TI 位，TI 位用于指定是 GDT，还是 LDT，TI 为 1 则表示在 LDT 中索引段描述符，即 TI
为 1 必然是经过显式初始化的结果，完全排除了忘记初始化的可能

### 打开A20地址线

![image-20241109200042334](/home/future/.config/Typora/typora-user-images/image-20241109200042334.png)

## boot.inc

`equ`是`nasm`提供的伪指令，意为`equal`，指令格式为`符号名称   equ    表达式`

## 处理器微架构简介

### 流水线

CPU是按照程序中指令顺序来填充流水线的，也就是按照程序计数器PC(X86当中是CS:IP)中的值来装载流水线的。

**`CPU`在遇到无条件转移指令`jmp`时，会清空流水线**

### 乱序执行

X86最初使用的指令集是`CISC(Complex Instruction Set Computer)`,意为复杂指令集计算机。

push eax 相当于：

* push 指令先将栈指针 esp 减去操作数的字长，如 sub esp,4。
* 再将操作数 mov 到新的 esp 指向的地址，如 mov [esp],eax。

这灵歌子操作合成了一个指令，其中每一个子操作称为**微操作**

与`CISC`指令集相对应的是`RISC(Reduced Instruction Set Computer)`，意为精简指令集计算机。

它精简保留了常用的指令、这些写指令大都是不可以在细分的。即他们基本上都是属于微操作级别的指令啦。

**乱序执行**的好处就是后面的操作可以放到前面来做，利于装载到流水线上提高效率。

### 缓存

需要一个比内存更快的存取设备做缓冲区，于是`SRAM(静态随即访问存储器)`成了**CPU**和**内存**之间数据缓存的不二之选。

什么时候缓存呢？

可以根据程序的局部性原理采取缓存策略。局部性原理是：程序 90%的时间都运行在程序中 10%的代码上。

局部性分为以下两个方面：

* 一方面是时间局部性：最近访问过的指令和数据，在将来一段时间内依然经常被访问。

* 另一方面是空间局部性：靠近当前访问内存空间的内存地址，在将来一段时间也会被访问。

### 分支预测

预测主要是针对跳转指令的，因为分支的出现会影响CPU流水线的效率。

对于无条件跳转、直接跳转过去就好、跳转主要是针对有条件的跳转

![image-20241118200203722](/home/future/.config/Typora/typora-user-images/image-20241118200203722.png)

## 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

代码段寄存器 cs，只有用远过程调用指令 call、远转移指令 jmp、远返回指令 retf 等指令间接改变。

`CPU`遇到**jmp**指令时，之前已经送上流水线上的指令只有清空。

## 保护模式之内存段的保护

1. 向段寄存器加载选择子时的保护

* 首先会根据选择子的值验证段描述符是否超越界限

​	选择子的高13位是段描述符的索引值。第0～1位是RPL.

​	判断标准是选择字的索引值一定要小于等于描述符表(GDT或者LDT)中描述符的个数

​	满足表达式**`描述符基地址+选择子中的索引值*8+7<=描述符表基地址+描述符表界限值`**

![image-20241118204023270](/home/future/.config/Typora/typora-user-images/image-20241118204023270.png)

* 段描述符当中还有一个`type`字段，检查完选择子之后就会进行段的类型检查。

![image-20241118204243871](/home/future/.config/Typora/typora-user-images/image-20241118204243871.png)

* 检查完`type`后，还会检查段是否存在.

​	CPU 通过段描述符中的 P 位来确认内存段是否存在，如果P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0，则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。这时候处理器会抛出异常，自转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。

2.代码段和栈段的保护

3.栈段的保护



